<html>
<head>
	<meta charset="utf-8">
	<title>Triangle Mesh Generation</title>
	<style>
	body {
		background-color: #CCC;
	}
	canvas {
		width: 500px;
		height: 500px;
		border: solid 1px gray;
		background-color: #EEE;
	}
	</style>
	<script type="text/javascript">
		var POINT_COUNT = 64;
		var POINT_SIZE = 4;
		var POINT_COLOR = 10;
		var CANVAS_WIDTH = 500;
		var CANVAS_HEIGHT = 500;

		var contexts = [];
		var points = [];
		var lineGroups = [];

		var selectedCanvas = 0;

		function Point(x, y, i) {
			this.x = x;
			this.y = y;
			this.index = i;
		}

		function Line(p1, p2) {
			this.p1 = p1;
			this.p2 = p2;

			var dX = p2.x - p1.x, dY = p2.y - p1.y;
			this.length = Math.sqrt( dX * dX + dY * dY );
		}


		function init() {
			contexts[0] = document.getElementById("cvs0").getContext("2d");
			contexts[1] = document.getElementById("cvs1").getContext("2d");
			lineGroups[0] = [];
			lineGroups[1] = [];
			generatePoints();
			render();
			onClickCanvas(0);
		}
		document.addEventListener("DOMContentLoaded", init);

		function generatePoints() {
			for (var i = 0; i < POINT_COUNT; i++) {
				points[i] = new Point(
					Math.random() * (CANVAS_WIDTH - 60) + 30,
					Math.random() * (CANVAS_HEIGHT - 60) + 30,
					i
				);
			}
			// console.log(points);
		}

		function isLineCross(line1, line2) {
			var x1 = line1.p1.x, y1 = line1.p1.y,
				x2 = line1.p2.x, y2 = line1.p2.y,
				x3 = line2.p1.x, y3 = line2.p1.y,
				x4 = line2.p2.x, y4 = line2.p2.y;
			var d = (y2 - y1) * (x4 - x3) - (y4 - y3) * (x2 - x1);
			if (d == 0) {
				return false;
			} else {
				var x0 = ((x2 - x1) * (x4 - x3) * (y3 - y1) + (y2 - y1) * (x4 - x3) * x1 - (y4 - y3) * (x2 - x1) * x3) / d;
				var y0 = ((y2 - y1) * (y4 - y3) * (x3 - x1) + (x2 - x1) * (y4 - y3) * y1 - (x4 - x3) * (y2 - y1) * y3) / -d;
				x0 = r9(x0); y0 = r9(y0);
				x1 = r9(x1); y1 = r9(y1);
				x2 = r9(x2); y2 = r9(y2);
				x3 = r9(x3); y3 = r9(y3);
				x4 = r9(x4); y4 = r9(y4);
				if  (   (x0 - x1) * (x0 - x2) < 0 &&
					    (x0 - x3) * (x0 - x4) < 0 && 
					    (y0 - y1) * (y0 - y2) < 0 && 
					    (y0 - y3) * (y0 - y4) < 0 ) {
					// console.log(x0 + "," + y0, x1 + "," + y1, x2 + "," + y2, x3 + "," + y3, x4 + "," + y4);
					return true;
				} else {
					return false;
				}
			}
		}

		function r9(num) {
			return Math.round(num * 10000) / 10000
		}
		function clearCanvas() {
			for (var i = 0; i < contexts.length; i++) {
				contexts[i].clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
			}
		}

		function drawPoints() {
			for (var i = 0; i < contexts.length; i++) {
				contexts[i].fillStyle = "purple";
				for(var j = 0; j < points.length; j++) {
					contexts[i].fillRect (
						points[j].x - POINT_SIZE / 2,
					 	points[j].y - POINT_SIZE / 2,
					  	POINT_SIZE,
					   	POINT_SIZE
				   	);
					contexts[i].fillText (
						j,
						points[j].x - POINT_SIZE / 2 + 6,
					 	points[j].y - POINT_SIZE / 2 + 6
				   	);
				}
			}
		}

		function drawLines() {
			for ( var i = 0; i < lineGroups.length; i++ ) {
				var lines = lineGroups[i];
				for ( var j = 0; j < lines.length; j++ ) {
					var p1 = lines[j].p1;
					var p2 = lines[j].p2;
					contexts[i].beginPath();
					contexts[i].moveTo(p1.x, p1.y);
					contexts[i].lineTo(p2.x, p2.y);
					contexts[i].stroke();
				}
			}
		}

		function render() {
			clearCanvas();
			drawLines();
			drawPoints();
		}

		// methods
		function randomLines() {
			contexts[selectedCanvas].strokeStyle = "red";
			var LINE_NUM = 50;
			var lines = lineGroups[selectedCanvas];
			lines.length = 0;
			for (var i = 0; i < LINE_NUM; i++) {
				var p1 = points[Math.floor(Math.random() * POINT_COUNT)];
				var p2 = points[Math.floor(Math.random() * POINT_COUNT)];
				lines.push(new Line(p1, p2));
			}
		}

		function allLines() {
			contexts[selectedCanvas].strokeStyle = "rgba(0, 0, 0, 0.2)";
			var lines = lineGroups[selectedCanvas];
			lines.length = 0;
			for (var i = 0; i < POINT_COUNT; i++) {
				for (var j = i + 1; j < POINT_COUNT; j++) {
					lines.push(new Line(points[i], points[j]));
				}
			}
			console.log("all line count: " + lines.length);
		}

		function noCrossLines() {
			contexts[selectedCanvas].strokeStyle = "orange";
			var lines = lineGroups[selectedCanvas];
			lines.length = 0;
			for ( var i = 0; i < POINT_COUNT; i++ ) {
				for ( var j = i + 1; j < POINT_COUNT; j++ ) {
					var newLine = new Line( points[i], points[j] );
					if ( ! isLineCrossWithBefore( newLine, lines ) ) {
						lines.push( newLine );
						// console.log("Add: ", i, j);
					} else {
						// console.log("Not add: ", i, j);
					}
				}
			}
		}

		// geometry functions
		function isLineCrossWithBefore(line, lineGroup) {
			for ( var i = 0; i < lineGroup.length; i ++ ) {
				if ( isLineCross( line, lineGroup[i] ) ) {
					// console.log("crossed with line: [" + lineGroup[i].p1.index + " - " + lineGroup[i].p2.index + "]");
					return true;
				}
			}
			return false;
		}

		function shortNoCrossLines() {
			contexts[selectedCanvas].strokeStyle = "#08F";
			var lines = lineGroups[selectedCanvas];
			lines.length = 0;
			for (var i = 0; i < POINT_COUNT; i++) {
				for (var j = i + 1; j < POINT_COUNT; j++) {
					lines.push(new Line(points[i], points[j]));
				}
			}


			for ( var i = 0; i < lines.length; i++ ) {
				while(lineTryKillOthers(lines[i], lines)) lineTryKillOthers(lines[i], lines);
			}
		}

		function shortNoCrossLines2() {
			var lines = lineGroups[selectedCanvas];
			lines.length = 0;
			for ( var i = 0; i < POINT_COUNT; i++ ) {
				for ( var j = i + 1; j < POINT_COUNT; j++ ) {
					var newLine = new Line( points[i], points[j] );
					pushLineCrossOutLongers( newLine, lines );
				}
			}
		}

		function lineTryKillOthers(line, lineGroup) {
			// step 1: To see wheather itself will be killed
			for( var i = 0; i < lineGroup.length; i ++ ) {
				if ( isLineCross( line, lineGroup[i] ) && line.length > lineGroup[i].length ) {
					// console.log("[" + line.p1.index + "-" + line.p2.index + "] suicide by [" + lineGroup[i].p1.index + "-" + lineGroup[i].p2.index + "]");
					lineGroup.splice(lineGroup.indexOf(line), 1); // willBeenKilled
					return true;
				}
			}

			// console.log("[" + line.p1.index + "-" + line.p2.index + "] killing its crosses.");
			for ( var i = 0; i < lineGroup.length; i ++ ) {
				if ( isLineCross( line, lineGroup[i] ) ) {
					// console.log("    [" + lineGroup[i].p1.index + "-" + lineGroup[i].p2.index + "] be killing");
					lineGroup.splice(i, 1);
				}
			}
			return false;
		}
		//必须先试试看有没有交线比它短，没有的话它才能去杀掉别的交线
		function lineTryKillOthers2(line, lineGroup) {
			for ( var i = 0; i < lineGroup.length; i ++ ) {
				if ( isLineCross( line, lineGroup[i] ) ) {
					if ( line.length < lineGroup[i].length ) {
						lineGroup.splice(i, 1);
					} else {
						lineGroup.splice(lineGroup.indexOf(line), 1);
						return;
					}
				}
			}

		}
		// is line is cross then
		function pushLineCrossOutLongers(line, lineGroup) {
			// step 1: calc wheather this line is the shortest.
			var isShortest = true;
			for ( var i = 0; i < lineGroup.length; i ++ ) {
				if (line.length > lineGroup[i].length) // TODO: > or >= determine wheather the answer is unique. 
					isShortest = false;
			}
			// console.log("new line shortest: " + isShortest);


			// step2: calc wheather cross
			var isCross = false;
			var groupLength = lineGroup.length;
			for ( var i = 0; i < groupLength; i ++ ) {
				if ( isLineCross( line, lineGroup[i] ) ) {
					if ( isShortest ) {
						// console.log(groupLength);
						lineGroup.splice(i, 1);
						groupLength --;
					}
					isCross = true;
				}
			}

			if (isShortest || (!isCross)) {
				lineGroup.push(line);
			}

		}

		function onClickCanvas(index) {
			selectedCanvas = index;
			for (var i = 0; i < 2; i++) {
				var dom = document.getElementById("cvs" + i);
				if (i == index)
					dom.style.borderColor = "blue";
				else 
					dom.style.borderColor = "gray";
			}
		}
	</script>
</head>
<body>
	<canvas id="cvs0" width="500" height="500" onclick="onClickCanvas(0);"></canvas>
	<canvas id="cvs1" width="500" height="500" onclick="onClickCanvas(1);"></canvas>
	<br>
	<button onclick="randomLines();render();">Random Lines</button>
	<button onclick="allLines();render();">All Lines</button>
	<button onclick="noCrossLines();render();">No Cross Lines</button>
	<button onclick="shortNoCrossLines();render();">Short No Cross Lines</button>
</body>
</html>