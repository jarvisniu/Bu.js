// Generated by CoffeeScript 1.10.0
var base, base1,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

this.Bu = {
  version: '0.2.0',
  DEFAULT_STROKE_STYLE: '#048',
  DEFAULT_FILL_STYLE: 'rgba(64, 128, 192, 0.5)',
  DEFAULT_DASH_STYLE: [8, 4],
  DEFAULT_STROKE_STYLE_HOVER: 'rgba(255, 128, 0, 0.75)',
  DEFAULT_FILL_STYLE_HOVER: 'rgba(255, 128, 128, 0.5)',
  DEFAULT_TEXT_FILL_STYLE: 'black',
  DEFAULT_IMAGE_SIZE: 20,
  POINT_RENDER_SIZE: 4,
  DEFAULT_BOUND_STROKE_STYLE: '#444',
  DEFAULT_BOUND_DASH_STYLE: [6, 6],
  DEFAULT_NEAR_DIST: 5,
  MOUSE_BUTTON_NONE: -1,
  MOUSE_BUTTON_LEFT: 0,
  MOUSE_BUTTON_MIDDLE: 1,
  MOUSE_BUTTON_RIGHT: 2
};


/*
 * math
 */

Bu.average = function() {
  var i, l, len1, ns, sum;
  ns = arguments;
  if (typeof arguments[0] === 'object') {
    ns = arguments[0];
  }
  sum = 0;
  for (l = 0, len1 = ns.length; l < len1; l++) {
    i = ns[l];
    sum += i;
  }
  return sum / ns.length;
};

Bu.bevel = function(x, y) {
  return Math.sqrt(x * x + y * y);
};

Bu.rand = function(from, to) {
  if (to == null) {
    to = from;
    from = 0;
  }
  return Math.random() * (to - from) + from;
};


/*
 * utils
 */

Bu.now = Date.now;

Bu.combineOptions = function(args, defaultOptions) {
  var givenOptions, i;
  if (defaultOptions == null) {
    defaultOptions = {};
  }
  givenOptions = args[args.length - 1];
  if (typeof givenOptions === 'object') {
    for (i in givenOptions) {
      defaultOptions[i] = givenOptions[i];
    }
  }
  return defaultOptions;
};


/*
 * polyfill
 */

Function.prototype.property = function(prop, desc) {
  return Object.defineProperty(this.prototype, prop, desc);
};

(base = Array.prototype).each || (base.each = function(fn) {
  var i;
  i = 0;
  while (i < this.length) {
    fn(this[i]);
    i++;
  }
  return this;
});

(base1 = Array.prototype).map || (base1.map = function(fn) {
  var arr, i;
  arr = [];
  i = 0;
  while (i < this.length) {
    arr.push(fn(this[i]));
    i++;
  }
  return this;
});

Bu.Vector = (function() {
  function Vector(x5, y5) {
    this.x = x5;
    this.y = y5;
  }

  Vector.prototype.set = function(x5, y5) {
    this.x = x5;
    this.y = y5;
  };

  return Vector;

})();

Bu.Event = function() {
  var types;
  types = {};
  this.on = function(type, listener) {
    var listeners;
    listeners = types[type] || (types[type] = []);
    if (listeners.indexOf(listener === -1)) {
      return listeners.push(listener);
    }
  };
  this.once = function(type, listener) {
    listener.once = true;
    return this.on(type, listener);
  };
  this.off = function(type, listener) {
    var index, listeners;
    listeners = types[type];
    if (listener != null) {
      if (listeners != null) {
        index = listeners.indexOf(listener);
        if (index > -1) {
          return listeners.splice(index, 1);
        }
      }
    } else {
      if (listeners != null) {
        return listeners.length = 0;
      }
    }
  };
  return this.trigger = function(type, eventData) {
    var l, len1, listener, listeners, results;
    listeners = types[type];
    if (listeners != null) {
      eventData || (eventData = {});
      eventData.target = this;
      results = [];
      for (l = 0, len1 = listeners.length; l < len1; l++) {
        listener = listeners[l];
        listener.call(this, eventData);
        if (listener.once) {
          listeners.splice(i, 1);
          results.push(i -= 1);
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };
};


/*
 * MicroJQuery - A micro version of jQuery
 *
 * Supported features:
 *   $. - static methods
 *     .ready(cb) - call the callback function after the page is loaded
 *     .ajax([url,] options) - perform an ajax request
 *   $(selector) - select element(s)
 *     .on(type, callback) - add an event listener
 *     .off(type, callback) - remove an event listener
 *     .append(tagName) - append a tag
 *     .text(text) - set the inner text
 *     .html(htmlText) - set the inner HTML
 *     .style(name, value) - set style (a css attribute)
 *     #.css(object) - set styles (multiple css attribute)
 *     .hasClass(className) - detect whether a class exists
 *     .addClass(className) - add a class
 *     .removeClass(className) - remove a class
 *     .toggleClass(className) - toggle a class
 *     .attr(name, value) - set an attribute
 *     .hasAttr(name) - detect whether an attribute exists
 *     .removeAttr(name) - remove an attribute
 *   Notes:
 *        # is planned but not implemented
 */

(function(global) {
  var jQuery;
  global.$ = function(selector) {
    var selections;
    selections = [];
    if (typeof selector === 'string') {
      selections = [].slice.call(document.querySelectorAll(selector));
    }
    jQuery.apply(selections);
    return selections;
  };
  jQuery = function() {
    var SVG_TAGS;
    this.on = (function(_this) {
      return function(type, callback) {
        _this.each(function(dom) {
          return dom.addEventListener(type, callback);
        });
        return _this;
      };
    })(this);
    this.off = (function(_this) {
      return function(type, callback) {
        _this.each(function(dom) {
          return dom.removeEventListener(type, callback);
        });
        return _this;
      };
    })(this);
    SVG_TAGS = 'svg line rect circle ellipse polyline polygon path text';
    this.append = (function(_this) {
      return function(tag) {
        _this.each(function(dom, i) {
          var newDom, tagIndex;
          tagIndex = SVG_TAGS.indexOf(tag.toLowerCase());
          if (tagIndex > -1) {
            newDom = document.createElementNS('http://www.w3.org/2000/svg', tag);
          } else {
            newDom = document.createElement(tag);
          }
          return _this[i] = dom.appendChild(newDom);
        });
        return _this;
      };
    })(this);
    this.text = (function(_this) {
      return function(str) {
        _this.each(function(dom) {
          return dom.textContent = str;
        });
        return _this;
      };
    })(this);
    this.html = (function(_this) {
      return function(str) {
        _this.each(function(dom) {
          return dom.innerHTML = str;
        });
        return _this;
      };
    })(this);
    this.style = (function(_this) {
      return function(name, value) {
        _this.each(function(dom) {
          var i, styleText, styles;
          styleText = dom.getAttribute('style');
          styles = {};
          if (styleText) {
            styleText.split(';').each(function(n) {
              var nv;
              nv = n.split(':');
              return styles[nv[0]] = nv[1];
            });
          }
          styles[name] = value;
          styleText = '';
          for (i in styles) {
            styleText += i + ': ' + styles[i] + '; ';
          }
          return dom.setAttribute('style', styleText);
        });
        return _this;
      };
    })(this);
    this.hasClass = (function(_this) {
      return function(name) {
        var classText, classes, i;
        if (_this.length === 0) {
          return false;
        }
        i = 0;
        while (i < _this.length) {
          classText = _this[i].getAttribute('class' || '');
          classes = classText.split(RegExp(' +'));
          if (!classes.contains(name)) {
            return false;
          }
          i++;
        }
        return _this;
      };
    })(this);
    this.addClass = (function(_this) {
      return function(name) {
        _this.each(function(dom) {
          var classText, classes;
          classText = dom.getAttribute('class' || '');
          classes = classText.split(RegExp(' +'));
          if (!classes.contains(name)) {
            classes.push(name);
            return dom.setAttribute('class', classes.join(' '));
          }
        });
        return _this;
      };
    })(this);
    this.removeClass = (function(_this) {
      return function(name) {
        _this.each(function(dom) {
          var classText, classes;
          classText = dom.getAttribute('class') || '';
          classes = classText.split(RegExp(' +'));
          if (classes.contains(name)) {
            classes.remove(name);
            if (classes.length > 0) {
              return dom.setAttribute('class', classes.join(' '));
            } else {
              return dom.removeAttribute('class');
            }
          }
        });
        return _this;
      };
    })(this);
    this.toggleClass = (function(_this) {
      return function(name) {
        _this.each(function(dom) {
          var classText, classes;
          classText = dom.getAttribute('class' || '');
          classes = classText.split(RegExp(' +'));
          if (classes.contains(name)) {
            classes.remove(name);
          } else {
            classes.push(name);
          }
          if (classes.length > 0) {
            return dom.setAttribute('class', classes.join(' '));
          } else {
            return dom.removeAttribute('class');
          }
        });
        return _this;
      };
    })(this);
    this.attr = (function(_this) {
      return function(name, value) {
        value || (value = '');
        _this.each(function(dom) {
          return dom.setAttribute(name, value);
        });
        return _this;
      };
    })(this);
    this.hasAttr = (function(_this) {
      return function(name) {
        var i;
        if (_this.length === 0) {
          return false;
        }
        i = 0;
        while (i < _this.length) {
          if (!_this[i].hasAttribute(name)) {
            return false;
          }
          i++;
        }
        return _this;
      };
    })(this);
    return this.removeAttr = (function(_this) {
      return function(name) {
        _this.each(function(dom) {
          return dom.removeAttribute(name);
        });
        return _this;
      };
    })(this);
  };
  global.$.ready = function(onLoad) {
    return document.addEventListener('DOMContentLoaded', onLoad);
  };

  /* $.ajax()
  		options:
  			url: string
  			====
  			async = true: bool
  			## data: object - query parameters TODO: implement this
  			method = GET: POST, PUT, DELETE, HEAD
  			username: string
  			password: string
  			success: function
  			error: function
  			complete: function
   */
  return global.$.ajax = function(url, ops) {
    var xhr;
    if (!ops) {
      if (typeof url === 'object') {
        ops = url;
        url = ops.url;
      } else {
        ops = {};
      }
    }
    ops.method || (ops.method = 'GET');
    if (ops.async == null) {
      ops.async = true;
    }
    xhr = new XMLHttpRequest;
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          if (ops.success != null) {
            return ops.success(xhr.responseText, xhr.status, xhr);
          }
        } else {
          if (ops.error != null) {
            ops.error(xhr, xhr.status);
          }
          if (ops.complete != null) {
            return ops.complete(xhr, xhr.status);
          }
        }
      }
    };
    xhr.open(ops.method, url, ops.async, ops.username, ops.password);
    return xhr.send(null);
  };
})(window || this);

Bu.Object2D = (function() {
  function Object2D() {
    Bu.Colorful.apply(this);
    Bu.Event.apply(this);
    this.visible = true;
    this.opacity = 1;
    this.position = new Bu.Vector();
    this.rotation = 0;
    this.scale = new Bu.Vector(1, 1);
    this.skew = new Bu.Vector();
    this.bounds = null;
    this.keyPoints = null;
    this.children = [];
    this.parent = null;
  }

  Object2D.prototype.containsPoint = function(p) {
    if ((this.bounds != null) && !this.bounds.containsPoint(p)) {
      return false;
    } else if (this._containsPoint) {
      return this._containsPoint(p);
    } else {
      return false;
    }
  };

  return Object2D;

})();

Bu.Size = (function() {
  function Size(width1, height1) {
    this.width = width1;
    this.height = height1;
    this.type = 'Size';
  }

  Size.prototype.set = function(width, height) {
    this.width = width;
    return this.height = height;
  };

  return Size;

})();

Bu.Bounds = (function(superClass) {
  extend(Bounds, superClass);

  function Bounds(target1) {
    var l, len1, len2, o, ref, ref1, v;
    this.target = target1;
    Bounds.__super__.constructor.call(this);
    this.type = 'Bounds';
    this.x1 = this.y1 = this.x2 = this.y2 = 0;
    this.isEmpty = true;
    this.point1 = new Bu.Point;
    this.point2 = new Bu.Point;
    this.strokeStyle = Bu.DEFAULT_BOUND_STROKE_STYLE;
    this.dashStyle = Bu.DEFAULT_BOUND_DASH_STYLE;
    this.dashDelta = 0;
    switch (this.target.type) {
      case 'Line':
      case 'Triangle':
      case 'Rectangle':
        ref = this.target.points;
        for (l = 0, len1 = ref.length; l < len1; l++) {
          v = ref[l];
          this.expandByPoint(v);
        }
        break;
      case 'Circle':
      case 'Bow':
      case 'Fan':
        this.expandByCircle(this.target);
        this.target.on('centerChanged', (function(_this) {
          return function() {
            _this.clear();
            return _this.expandByCircle(_this.target);
          };
        })(this));
        this.target.on('radiusChanged', (function(_this) {
          return function() {
            _this.clear();
            return _this.expandByCircle(_this.target);
          };
        })(this));
        break;
      case 'Polyline':
      case 'Polygon':
        ref1 = this.target.vertices;
        for (o = 0, len2 = ref1.length; o < len2; o++) {
          v = ref1[o];
          this.expandByPoint(v);
        }
        break;
      default:
        console.warn('Bounds: not support shape type "' + this.target.type + '"');
    }
  }

  Bounds.prototype.containsPoint = function(p) {
    return this.x1 < p.x && this.x2 > p.x && this.y1 < p.y && this.y2 > p.y;
  };

  Bounds.prototype.clear = function() {
    this.x1 = this.y1 = this.x2 = this.y2 = 0;
    return this.isEmpty = true;
  };

  Bounds.prototype.expandByPoint = function(v) {
    if (this.isEmpty) {
      this.isEmpty = false;
      this.x1 = this.x2 = v.x;
      return this.y1 = this.y2 = v.y;
    } else {
      if (v.x < this.x1) {
        this.x1 = v.x;
      }
      if (v.x > this.x2) {
        this.x2 = v.x;
      }
      if (v.y < this.y1) {
        this.y1 = v.y;
      }
      if (v.y > this.y2) {
        return this.y2 = v.y;
      }
    }
  };

  Bounds.prototype.expandByCircle = function(c) {
    var cp, r;
    cp = c.center;
    r = c.radius;
    if (this.isEmpty) {
      this.isEmpty = false;
      this.x1 = cp.x - r;
      this.x2 = cp.x + r;
      this.y1 = cp.y - r;
      return this.y2 = cp.y + r;
    } else {
      if (cp.x - r < this.x1) {
        this.x1 = cp.x - r;
      }
      if (cp.x + r > this.x2) {
        this.x2 = cp.x + r;
      }
      if (cp.y - r < this.y1) {
        this.y1 = cp.y - r;
      }
      if (cp.y + r > this.y2) {
        return this.y2 = cp.y + r;
      }
    }
  };

  return Bounds;

})(Bu.Object2D);

Bu.Colorful = function() {
  this.strokeStyle = Bu.DEFAULT_STROKE_STYLE;
  this.fillStyle = Bu.DEFAULT_FILL_STYLE;
  this.dashStyle = false;
  this.lineWidth = 1;
  this.dashDelta = 0;
  this.stroke = function(v) {
    if (v == null) {
      v = true;
    }
    switch (v) {
      case true:
        this.strokeStyle = Bu.DEFAULT_STROKE_STYLE;
        break;
      case false:
        this.strokeStyle = null;
        break;
      default:
        this.strokeStyle = v;
    }
    return this;
  };
  this.fill = function(v) {
    if (v == null) {
      v = true;
    }
    switch (v) {
      case false:
        this.fillStyle = null;
        break;
      case true:
        this.fillStyle = Bu.DEFAULT_FILL_STYLE;
        break;
      default:
        this.fillStyle = v;
    }
    return this;
  };
  return this.dash = function(v) {
    if (v == null) {
      v = true;
    }
    if (typeof v === 'number') {
      v = [v, v];
    }
    switch (v) {
      case false:
        this.dashStyle = null;
        break;
      case true:
        this.dashStyle = Bu.DEFAULT_DASH_STYLE;
        break;
      default:
        this.dashStyle = v;
    }
    return this;
  };
};

Bu.Point = (function(superClass) {
  var footPoint;

  extend(Point, superClass);

  function Point(x5, y5) {
    this.x = x5 != null ? x5 : 0;
    this.y = y5 != null ? y5 : 0;
    Point.__super__.constructor.call(this);
    this.stroke(false);
    this.type = 'Point';
    this._labelIndex = -1;
  }

  Point.property('label', {
    get: function() {
      if (this._labelIndex > -1) {
        return this.children[this._labelIndex].text;
      } else {
        return '';
      }
    },
    set: function(val) {
      var pointText;
      if (this._labelIndex === -1) {
        pointText = new Bu.PointText(val, this.x + Bu.POINT_RENDER_SIZE, this.y, {
          align: '+0'
        });
        this.children.push(pointText);
        return this._labelIndex = this.children.length - 1;
      } else {
        return this.children[this._labelIndex].text = val;
      }
    }
  });

  Point.prototype.arcTo = function(radius, arc) {
    return new Bu.Point(this.x + Math.cos(arc) * radius, this.y + Math.sin(arc) * radius);
  };

  Point.prototype.clone = function() {
    return new Bu.Point(this.x, this.y);
  };

  Point.prototype.copy = function(point) {
    this.x = point.x;
    this.y = point.y;
    return this.updateLabel();
  };

  Point.prototype.set = function(x, y) {
    this.x = x;
    this.y = y;
    return this.updateLabel();
  };

  Point.prototype.updateLabel = function() {
    if (this._labelIndex > -1) {
      this.children[this._labelIndex].x = this.x + Bu.POINT_RENDER_SIZE;
      return this.children[this._labelIndex].y = this.y;
    }
  };

  Point.prototype.distanceTo = function(point) {
    return Bu.bevel(this.x - point.x, this.y - point.y);
  };

  footPoint = null;

  Point.prototype.isNear = function(target, limit) {
    var isBetween1, isBetween2, l, len1, line, ref, verticalDist;
    if (limit == null) {
      limit = Bu.DEFAULT_NEAR_DIST;
    }
    switch (target.type) {
      case 'Point':
        return this.distanceTo(target) < limit;
      case 'Line':
        verticalDist = target.distanceTo(this);
        if (footPoint == null) {
          footPoint = new Bu.Point;
        }
        target.footPointFrom(this, footPoint);
        isBetween1 = footPoint.distanceTo(target.points[0]) < target.length + Bu.DEFAULT_NEAR_DIST;
        isBetween2 = footPoint.distanceTo(target.points[1]) < target.length + Bu.DEFAULT_NEAR_DIST;
        return verticalDist < limit && isBetween1 && isBetween2;
      case 'Polyline':
        ref = target.lines;
        for (l = 0, len1 = ref.length; l < len1; l++) {
          line = ref[l];
          if (this.isNear(line)) {
            return true;
          }
        }
        return false;
    }
  };

  return Point;

})(Bu.Object2D);

Bu.Point.interpolate = function(p1, p2, k, p3) {
  var x, y;
  x = p1.x + (p2.x - p1.x) * k;
  y = p1.y + (p2.y - p1.y) * k;
  if (p3 != null) {
    return p3.set(x, y);
  } else {
    return new Bu.Point(x, y);
  }
};

Bu.Line = (function(superClass) {
  extend(Line, superClass);

  function Line(p1, p2, p3, p4) {
    Line.__super__.constructor.call(this);
    this.type = 'Line';
    if (arguments.length < 2) {
      this.points = [new Bu.Point(), new Bu.Point()];
    } else if (arguments.length < 4) {
      this.points = [p1.clone(), p2.clone()];
    } else {
      this.points = [new Bu.Point(p1, p2), new Bu.Point(p3, p4)];
    }
    this.length;
    this.midpoint = new Bu.Point();
    this.keyPoints = this.points;
    this.on("pointChange", (function(_this) {
      return function(e) {
        _this.length = _this.points[0].distanceTo(_this.points[1]);
        return _this.midpoint.set((_this.points[0].x + _this.points[1].x) / 2, (_this.points[0].y + _this.points[1].y) / 2);
      };
    })(this));
    this.trigger("pointChange", this);
  }

  Line.prototype.set = function(a1, a2, a3, a4) {
    if (typeof p4 !== "undefined" && p4 !== null) {
      this.points[0].set(a1, a2);
      this.points[1].set(a3, a4);
    } else {
      this.points[0] = a1;
      this.points[1] = a2;
    }
    this.trigger("pointChange", this);
    return this;
  };

  Line.prototype.setPoint1 = function(a1, a2) {
    if (a2 != null) {
      this.points[0].set(a1, a2);
    } else {
      this.points[0].copy(a1);
    }
    this.trigger("pointChange", this);
    return this;
  };

  Line.prototype.setPoint2 = function(a1, a2) {
    if (a2 != null) {
      this.points[1].set(a1, a2);
    } else {
      this.points[1].copy(a1);
    }
    this.trigger("pointChange", this);
    return this;
  };

  Line.prototype.isTwoPointsSameSide = function(p1, p2) {
    var pA, pB, y01, y02;
    pA = this.points[0];
    pB = this.points[1];
    if (pA.x === pB.x) {
      return (p1.x - pA.x) * (p2.x - pA.x) > 0;
    } else {
      y01 = (pA.y - pB.y) * (p1.x - pA.x) / (pA.x - pB.x) + pA.y;
      y02 = (pA.y - pB.y) * (p2.x - pA.x) / (pA.x - pB.x) + pA.y;
      return (p1.y - y01) * (p2.y - y02) > 0;
    }
  };

  Line.prototype.distanceTo = function(point) {
    var a, b, p1, p2;
    p1 = this.points[0];
    p2 = this.points[1];
    a = (p1.y - p2.y) / (p1.x - p2.x);
    b = p1.y - a * p1.x;
    return Math.abs(a * point.x + b - point.y) / Math.sqrt(a * a + 1);
  };

  Line.prototype.distanceTo2 = function(point) {
    var a, b, czX, czY, p1, p2;
    p1 = this.points[0];
    p2 = this.points[1];
    a = (p1.y - p2.y) / (p1.x - p2.x);
    b = p1.y - (p1.y - p2.y) * p1.x / (p1.x - p2.x);
    czX = (point.y + point.x / a - b) / (a + 1 / a);
    czY = a * czX + b;
    return Bu.bevel(czX - point.x, czY - point.y);
  };

  Line.prototype.footPointFrom = function(point, footPoint) {
    var A, B, m, p1, p2, x, y;
    p1 = this.points[0];
    p2 = this.points[1];
    A = (p1.y - p2.y) / (p1.x - p2.x);
    B = p1.y - A * p1.x;
    m = point.x + A * point.y;
    x = (m - A * B) / (A * A + 1);
    y = A * x + B;
    if (footPoint != null) {
      return footPoint.set(x, y);
    } else {
      return new Bu.Point(x, y);
    }
  };

  Line.prototype.getCrossPointWith = function(line) {
    var a1, a2, b1, b2, c1, c2, det, p1, p2, q1, q2;
    p1 = this.points[0];
    p2 = this.points[1];
    q1 = line.points[0];
    q2 = line.points[1];
    a1 = p2.y - p1.y;
    b1 = p1.x - p2.x;
    c1 = (a1 * p1.x) + (b1 * p1.y);
    a2 = q2.y - q1.y;
    b2 = q1.x - q2.x;
    c2 = (a2 * q1.x) + (b2 * q1.y);
    det = (a1 * b2) - (a2 * b1);
    return new Bu.Point(((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det);
  };

  Line.prototype.isCrossWithLine = function(line) {
    var d, x0, x1, x2, x3, x4, y0, y1, y2, y3, y4;
    x1 = this.points[0].x;
    y1 = this.points[0].y;
    x2 = this.points[1].x;
    y2 = this.points[1].y;
    x3 = line.points[0].x;
    y3 = line.points[0].y;
    x4 = line.points[1].x;
    y4 = line.points[1].y;
    d = (y2 - y1) * (x4 - x3) - (y4 - y3) * (x2 - x1);
    if (d === 0) {
      return false;
    } else {
      x0 = ((x2 - x1) * (x4 - x3) * (y3 - y1) + (y2 - y1) * (x4 - x3) * x1 - (y4 - y3) * (x2 - x1) * x3) / d;
      y0 = ((y2 - y1) * (y4 - y3) * (x3 - x1) + (x2 - x1) * (y4 - y3) * y1 - (x4 - x3) * (y2 - y1) * y3) / -d;
    }
    return (x0 - x1) * (x0 - x2) < 0 && (x0 - x3) * (x0 - x4) < 0 && (y0 - y1) * (y0 - y2) < 0 && (y0 - y3) * (y0 - y4) < 0;
  };

  Line.prototype.isCrossWithLine2 = function(line) {
    var da, db, dx, dy, p1, p2, q1, q2, s, t;
    p1 = this.points[0];
    p2 = this.points[1];
    q1 = line.points[0];
    q2 = line.points[1];
    dx = p2.x - p1.x;
    dy = p2.y - p1.y;
    da = q2.x - q1.x;
    db = q2.y - q1.y;
    if (da * dy - db * dx === 0) {
      return false;
    }
    s = (dx * (q1.y - p1.y) + dy * (p1.x - q1.x)) / (da * dy - db * dx);
    t = (da * (p1.y - q1.y) + db * (q1.x - p1.x)) / (db * dx - da * dy);
    return s >= 0 && s <= 1 && t >= 0 && t <= 1;
  };

  return Line;

})(Bu.Object2D);

Bu.Circle = (function(superClass) {
  extend(Circle, superClass);

  function Circle(cx, cy, _radius) {
    if (cx == null) {
      cx = 0;
    }
    if (cy == null) {
      cy = 0;
    }
    this._radius = _radius != null ? _radius : 1;
    Circle.__super__.constructor.call(this);
    this.type = 'Circle';
    this._center = new Bu.Point(cx, cy);
    this.bounds = null;
    this.keyPoints = [this._center];
  }

  Circle.property('cx', {
    get: function() {
      return this._center.x;
    },
    set: function(val) {
      this._center.x = val;
      return this.trigger('centerChanged', this);
    }
  });

  Circle.property('cy', {
    get: function() {
      return this._center.y;
    },
    set: function(val) {
      this._center.y = val;
      return this.trigger('centerChanged', this);
    }
  });

  Circle.property('center', {
    get: function() {
      return this._center;
    },
    set: function(val) {
      this._center = val;
      this.cx = val.x;
      this.cy = val.y;
      this.keyPoints[0] = val;
      return this.trigger('centerChanged', this);
    }
  });

  Circle.property('radius', {
    get: function() {
      return this._radius;
    },
    set: function(val) {
      this._radius = val;
      this.trigger('radiusChanged', this);
      return this;
    }
  });

  Circle.prototype._containsPoint = function(p) {
    var dx, dy;
    dx = p.x - this.cx;
    dy = p.y - this.cy;
    return Bu.bevel(dx, dy) < this.radius;
  };

  return Circle;

})(Bu.Object2D);

Bu.Triangle = (function(superClass) {
  extend(Triangle, superClass);

  function Triangle(p1, p2, p3) {
    Triangle.__super__.constructor.call(this);
    this.type = 'Triangle';
    this.lines = [new Bu.Line(p1, p2), new Bu.Line(p2, p3), new Bu.Line(p3, p1)];
    this.center = new Bu.Point(Bu.average(p1.x, p2.x, p3.x), Bu.average(p1.y, p2.y, p3.y));
    this.points = [p1, p2, p3];
    this.keyPoints = this.points;
  }

  Triangle.prototype.area = function() {
    var a, b, c;
    a = this.points[0];
    b = this.points[1];
    c = this.points[2];
    return ((b.x - a.x) * (c.y - a.y)) - ((c.x - a.x) * (b.y - a.y));
  };

  Triangle.prototype._containsPoint = function(p) {
    return this.lines[0].isTwoPointsSameSide(p, this.points[2]) && this.lines[1].isTwoPointsSameSide(p, this.points[0]) && this.lines[2].isTwoPointsSameSide(p, this.points[1]);
  };

  return Triangle;

})(Bu.Object2D);

Bu.Rectangle = (function(superClass) {
  extend(Rectangle, superClass);

  function Rectangle(x, y, width, height) {
    Rectangle.__super__.constructor.call(this);
    this.type = 'Rectangle';
    this.position = new Bu.Point(x, y);
    this.center = new Bu.Point(x + width / 2, y + height / 2);
    this.size = new Bu.Size(width, height);
    this.pointRT = new Bu.Point(x + width, y);
    this.pointRB = new Bu.Point(x + width, y + height);
    this.pointLB = new Bu.Point(x, y + height);
    this.points = [this.position, this.pointRT, this.pointRB, this.pointLB];
    this.keyPoints = this.points;
  }

  Rectangle.prototype.containsPoint = function(point) {
    return point.x > this.position.x && point.y > this.position.y && point.x < this.position.x + this.size.width && point.y < this.position.y + this.size.height;
  };

  return Rectangle;

})(Bu.Object2D);

Bu.Fan = (function(superClass) {
  extend(Fan, superClass);

  function Fan(cx1, cy1, radius1, aFrom1, aTo1) {
    this.cx = cx1;
    this.cy = cy1;
    this.radius = radius1;
    this.aFrom = aFrom1;
    this.aTo = aTo1;
    Fan.__super__.constructor.call(this);
    this.type = 'Fan';
    this.center = new Bu.Point(this.cx, this.cy);
    this.string = new Bu.Line(this.center.arcTo(this.radius, this.aFrom), this.center.arcTo(this.radius, this.aTo));
    this.keyPoints = this.string.points;
  }

  Fan.prototype._containsPoint = function(p) {
    var a, dx, dy;
    dx = p.x - this.cx;
    dy = p.y - this.cy;
    a = Math.atan2(p.y - this.cy, p.x - this.cx);
    while (a < this.aFrom) {
      a += Math.PI * 2;
    }
    return Bu.bevel(dx, dy) < this.radius && a > this.aFrom && a < this.aTo;
  };

  return Fan;

})(Bu.Object2D);

Bu.Bow = (function(superClass) {
  extend(Bow, superClass);

  function Bow(cx1, cy1, radius1, aFrom1, aTo1) {
    var ref;
    this.cx = cx1;
    this.cy = cy1;
    this.radius = radius1;
    this.aFrom = aFrom1;
    this.aTo = aTo1;
    Bow.__super__.constructor.call(this);
    if (this.aFrom > this.aTo) {
      ref = [this.aTo, this.aFrom], this.aFrom = ref[0], this.aTo = ref[1];
    }
    this.type = 'Bow';
    this.center = new Bu.Point(this.cx, this.cy);
    this.string = new Bu.Line(this.center.arcTo(this.radius, this.aFrom), this.center.arcTo(this.radius, this.aTo));
    this.keyPoints = this.string.points;
  }

  Bow.prototype._containsPoint = function(point) {
    var sameSide, smallThanHalfCircle;
    if (Bu.bevel(this.cx - point.x, this.cy - point.y) < this.radius) {
      sameSide = this.string.isTwoPointsSameSide(this.center, point);
      smallThanHalfCircle = this.aTo - this.aFrom < Math.PI;
      return sameSide ^ smallThanHalfCircle;
    } else {
      return false;
    }
  };

  return Bow;

})(Bu.Object2D);

Bu.Polygon = (function(superClass) {
  extend(Polygon, superClass);


  /*
     constructors
     1. Polygon(points)
     2. Polygon(x, y, n, options): to generate regular polygon
     	options: radius, angle
   */

  function Polygon(points) {
    var i, l, n, o, options, ref, ref1, x, y;
    Polygon.__super__.constructor.call(this);
    this.type = 'Polygon';
    this.vertices = [];
    this.lines = [];
    this.triangles = [];
    options = Bu.combineOptions(arguments, {
      radius: 100,
      angle: 0
    });
    if (points instanceof Array) {
      if (points != null) {
        this.vertices = points;
      }
    } else {
      x = arguments[0];
      y = arguments[1];
      n = arguments[2];
      this.vertices = Bu.Polygon.generateRegularPoints(x, y, n, options);
    }
    if (this.vertices.length > 1) {
      for (i = l = 0, ref = this.vertices.length - 1; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        this.lines.push(new Bu.Line(this.vertices[i], this.vertices[i + 1]));
      }
      this.lines.push(new Bu.Line(this.vertices[this.vertices.length - 1], this.vertices[0]));
    }
    if (this.vertices.length > 2) {
      for (i = o = 1, ref1 = this.vertices.length - 1; 1 <= ref1 ? o < ref1 : o > ref1; i = 1 <= ref1 ? ++o : --o) {
        this.triangles.push(new Bu.Triangle(this.vertices[0], this.vertices[i], this.vertices[i + 1]));
      }
    }
    this.keyPoints = this.vertices;
  }

  Polygon.prototype.isSimple = function() {
    var i, j, l, len, o, ref, ref1, ref2;
    len = this.lines.length;
    for (i = l = 0, ref = len; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      for (j = o = ref1 = i + 1, ref2 = len; ref1 <= ref2 ? o < ref2 : o > ref2; j = ref1 <= ref2 ? ++o : --o) {
        if (this.lines[i].isCrossWithLine(this.lines[j])) {
          return false;
        }
      }
    }
    return true;
  };

  Polygon.prototype.addPoint = function(point, insertIndex) {
    if (insertIndex == null) {
      this.vertices.push(point);
      if (this.vertices.length > 1) {
        this.lines[this.lines.length - 1].points[1] = point;
      }
      if (this.vertices.length > 0) {
        this.lines.push(new Bu.Line(this.vertices[this.vertices.length - 1], this.vertices[0]));
      }
      if (this.vertices.length > 2) {
        return this.triangles.push(new Bu.Triangle(this.vertices[0], this.vertices[this.vertices.length - 2], this.vertices[this.vertices.length - 1]));
      }
    } else {
      return this.vertices.splice(insertIndex, 0, point);
    }
  };

  Polygon.prototype._containsPoint = function(p) {
    var l, len1, ref, triangle;
    ref = this.triangles;
    for (l = 0, len1 = ref.length; l < len1; l++) {
      triangle = ref[l];
      if (triangle.containsPoint(p)) {
        return true;
      }
    }
    return false;
  };

  Polygon.generateRegularPoints = function(cx, cy, n, options) {
    var a, angleDelta, angleSection, i, l, points, r, ref, x, y;
    angleDelta = options.angle;
    r = options.radius;
    points = [];
    angleSection = Math.PI * 2 / n;
    for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      a = i * angleSection + angleDelta;
      x = cx + r * Math.cos(a);
      y = cy + r * Math.sin(a);
      points[i] = new Bu.Point(x, y);
    }
    return points;
  };

  return Polygon;

})(Bu.Object2D);

Bu.Polyline = (function(superClass) {
  var onPointChange, set;

  extend(Polyline, superClass);

  function Polyline(vertices) {
    this.vertices = vertices != null ? vertices : [];
    this.calcLength = bind(this.calcLength, this);
    this.updateLines = bind(this.updateLines, this);
    Polyline.__super__.constructor.call(this);
    this.type = 'Polyline';
    this.lines = [];
    this.length = 0;
    this.pointNormalizedPos = [];
    this.keyPoints = this.vertices;
    onPointChange(this);
  }

  onPointChange = function(self) {
    if (self.vertices.length > 1) {
      self.updateLines();
      self.calcLength();
      return self.calcPointNormalizedPos();
    }
  };

  Polyline.prototype.updateLines = function() {
    var i, l, ref, results;
    results = [];
    for (i = l = 0, ref = this.vertices.length - 1; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      if (this.lines[i] != null) {
        results.push(this.lines[i].set(this.vertices[i], this.vertices[i + 1]));
      } else {
        results.push(this.lines[i] = new Bu.Line(this.vertices[i], this.vertices[i + 1]));
      }
    }
    return results;
  };

  Polyline.prototype.calcLength = function() {
    var i, l, len, ref;
    if (this.vertices.length < 2) {
      return this.length = 0;
    } else {
      len = 0;
      for (i = l = 1, ref = this.vertices.length; 1 <= ref ? l < ref : l > ref; i = 1 <= ref ? ++l : --l) {
        len += this.vertices[i].distanceTo(this.vertices[i - 1]);
      }
      return this.length = len;
    }
  };

  Polyline.prototype.calcPointNormalizedPos = function() {
    var currPos, i, l, ref, results;
    currPos = 0;
    this.pointNormalizedPos[0] = 0;
    results = [];
    for (i = l = 1, ref = this.vertices.length; 1 <= ref ? l < ref : l > ref; i = 1 <= ref ? ++l : --l) {
      currPos += this.vertices[i].distanceTo(this.vertices[i - 1]) / this.length;
      results.push(this.pointNormalizedPos[i] = currPos);
    }
    return results;
  };

  Polyline.prototype.getNormalizedPos = function(index) {
    if (index != null) {
      return this.pointNormalizedPos[index];
    } else {
      return this.pointNormalizedPos;
    }
  };

  set = function(points) {
    var i, l, ref;
    for (i = l = 0, ref = this.vertices.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      this.vertices[i].copy(points[i]);
    }
    if (this.vertices.length > points.length) {
      this.vertices.splice(points.length);
    }
    return onPointChange(this);
  };

  Polyline.prototype.addPoint = function(point, insertIndex) {
    if (insertIndex == null) {
      this.vertices.push(point);
      if (this.vertices.length > 1) {
        this.lines.push(new Bu.Line(this.vertices[this.vertices.length - 2], this.vertices[this.vertices.length - 1]));
      }
    } else {
      this.vertices.splice(insertIndex, 0, point);
    }
    return onPointChange(this);
  };

  return Polyline;

})(Bu.Object2D);

Bu.PointText = (function(superClass) {
  extend(PointText, superClass);


  /*
  	options.align:
  	----------------------
  	|   --    0-    +-   |
  	|         |↙00      |
  	|   -0  --+->   +0   |
  	|         ↓          |
  	|   -+    0+    ++   |
  	----------------------
  	for example: text is in the right top of the point, then align = "+-"
   */

  function PointText(text, x5, y5) {
    var options;
    this.text = text;
    this.x = x5;
    this.y = y5;
    this.setContextAlign = bind(this.setContextAlign, this);
    PointText.__super__.constructor.call(this);
    this.type = 'PointText';
    this.strokeStyle = null;
    this.fillStyle = Bu.DEFAULT_TEXT_FILL_STYLE;
    options = Bu.combineOptions(arguments, {
      align: '00',
      fontFamily: 'Verdana',
      fontSize: 11
    });
    this.align = options.align;
    this._fontFamily = options.fontFamily;
    this._fontSize = options.fontSize;
    this.font = (this._fontSize + "px " + this._fontFamily) || options.font;
    this.setContextAlign(this.align);
  }

  PointText.property('fontFamily', {
    get: function() {
      return this._fontFamily;
    },
    set: function(val) {
      this._fontFamily = val;
      return this.font = this._fontSize + "px " + this._fontFamily;
    }
  });

  PointText.property('fontSize', {
    get: function() {
      return this._fontSize;
    },
    set: function(val) {
      this._fontSize = val;
      return this.font = this._fontSize + "px " + this._fontFamily;
    }
  });

  PointText.prototype.setContextAlign = function(align) {
    var alignX, alignY;
    if (align.length === 1) {
      align = '' + align + align;
    }
    alignX = align.substring(0, 1);
    alignY = align.substring(1, 2);
    this.textAlign = (function() {
      switch (alignX) {
        case '-':
          return 'right';
        case '0':
          return 'center';
        case '+':
          return 'left';
      }
    })();
    return this.textBaseline = (function() {
      switch (alignY) {
        case '-':
          return 'bottom';
        case '0':
          return 'middle';
        case '+':
          return 'top';
      }
    })();
  };

  return PointText;

})(Bu.Object2D);

Bu.Image = (function(superClass) {
  extend(Image, superClass);

  function Image(url1, x, y, width, height) {
    this.url = url1;
    Image.__super__.constructor.call(this);
    this.type = 'Image';
    this.autoSize = true;
    this.size = new Bu.Size(Bu.DEFAULT_IMAGE_SIZE, Bu.DEFAULT_IMAGE_SIZE);
    this.position = new Bu.Vector(x, y);
    this.center = new Bu.Vector(x + width / 2, y + height / 2);
    if (width != null) {
      this.size.set(width, height);
      this.autoSize = false;
    }
    this.pivot = new Bu.Vector(0.5, 0.5);
    this.image = new window.Image;
    this.loaded = false;
    this.image.onload = (function(_this) {
      return function(e) {
        if (_this.autoSize) {
          _this.size.set(_this.image.width, _this.image.height);
        }
        return _this.loaded = true;
      };
    })(this);
    this.image.src = this.url;
  }

  return Image;

})(Bu.Object2D);

Bu.Renderer = (function() {
  function Renderer() {
    this.drawShape = bind(this.drawShape, this);
    this.drawShapes = bind(this.drawShapes, this);
    var onResize, options, tick;
    Bu.Event.apply(this);
    this.type = 'Renderer';
    this.pixelRatio = (typeof window !== "undefined" && window !== null ? window.devicePixelRatio : void 0) || 1;
    options = Bu.combineOptions(arguments, {
      width: 800,
      height: 600,
      fps: 60,
      fillParent: false,
      showKeyPoints: false,
      border: false
    });
    this.width = options.width;
    this.height = options.height;
    this.fps = options.fps;
    this.container = options.container;
    this.fillParent = options.fillParent;
    this.isShowKeyPoints = options.showKeyPoints;
    this.tickCount = 0;
    this.isRunning = false;
    this.dom = document.createElement('canvas');
    this.context = this.dom.getContext('2d');
    this.context.textBaseline = 'top';
    if (typeof ClipMeter !== "undefined" && ClipMeter !== null) {
      this.clipMeter = new ClipMeter();
    }
    this.shapes = [];
    if (!this.fillParent) {
      this.dom.style.width = (this.width / this.pixelRatio) + 'px';
      this.dom.style.height = (this.height / this.pixelRatio) + 'px';
      this.dom.width = this.width;
      this.dom.height = this.height;
    }
    if ((options.border != null) && options.border) {
      this.dom.style.border = 'solid 1px gray';
    }
    this.dom.style.cursor = 'crosshair';
    this.dom.style.boxSizing = 'border-box';
    this.dom.style.background = '#eee';
    this.dom.oncontextmenu = function() {
      return false;
    };
    window.canvas = this.dom;
    onResize = (function(_this) {
      return function() {
        var canvasRatio, containerRatio, height, width;
        canvasRatio = _this.dom.height / _this.dom.width;
        containerRatio = _this.container.clientHeight / _this.container.clientWidth;
        if (containerRatio < canvasRatio) {
          height = _this.container.clientHeight;
          width = height / containerRatio;
        } else {
          width = _this.container.clientWidth;
          height = width * containerRatio;
        }
        _this.width = _this.dom.width = width * _this.pixelRatio;
        _this.height = _this.dom.height = height * _this.pixelRatio;
        _this.dom.style.width = width + 'px';
        _this.dom.style.height = height + 'px';
        return _this.render();
      };
    })(this);
    if (this.fillParent) {
      window.addEventListener('resize', onResize);
      this.dom.addEventListener('DOMNodeInserted', onResize);
    }
    tick = (function(_this) {
      return function() {
        _this.startRenderTime = Bu.now();
        if (_this.isRunning) {
          if (_this.clipMeter != null) {
            _this.clipMeter.start();
          }
          _this.render();
          _this.trigger('update', {
            'tickCount': _this.tickCount
          });
          _this.tickCount += 1;
          if (_this.clipMeter != null) {
            _this.clipMeter.tick();
          }
        }
        _this.endRenderTime = Bu.now();
        _this.nextRenderTime = Math.max(1000 / _this.fps - _this.endRenderTime + _this.startRenderTime, 1);
        return setTimeout(tick, _this.nextRenderTime);
      };
    })(this);
    tick();
    if (this.container != null) {
      if (typeof this.container === 'string') {
        this.container = document.querySelector(this.container);
      }
      setTimeout((function(_this) {
        return function() {
          return _this.container.appendChild(_this.dom);
        };
      })(this), 100);
    }
    this.isRunning = true;
  }

  Renderer.prototype.pause = function() {
    return this.isRunning = false;
  };

  Renderer.prototype["continue"] = function() {
    return this.isRunning = true;
  };

  Renderer.prototype.toggle = function() {
    return this.isRunning = !this.isRunning;
  };

  Renderer.prototype.processArgs = function(e) {
    return {
      offsetX: e.offsetX * this.pixelRatio,
      offsetY: e.offsetY * this.pixelRatio,
      button: e.button
    };
  };

  Renderer.prototype.append = function(shape) {
    var l, len1, s;
    if (shape instanceof Array) {
      for (l = 0, len1 = shape.length; l < len1; l++) {
        s = shape[l];
        this.shapes.push(s);
      }
    } else {
      this.shapes.push(shape);
    }
    return this;
  };

  Renderer.prototype.render = function() {
    this.clearCanvas();
    this.drawShapes(this.shapes);
    return this;
  };

  Renderer.prototype.clearCanvas = function() {
    this.context.clearRect(0, 0, this.width, this.height);
    return this;
  };

  Renderer.prototype.drawShapes = function(shapes) {
    var l, len1, shape;
    if (shapes != null) {
      for (l = 0, len1 = shapes.length; l < len1; l++) {
        shape = shapes[l];
        this.drawShape(shape);
      }
    }
    return this;
  };

  Renderer.prototype.drawShape = function(shape) {
    if (!shape.visible) {
      return this;
    }
    switch (shape.type) {
      case 'Point':
        this.drawPoint(shape);
        break;
      case 'Line':
        this.drawLine(shape);
        break;
      case 'Circle':
        this.drawCircle(shape);
        break;
      case 'Triangle':
        this.drawTriangle(shape);
        break;
      case 'Rectangle':
        this.drawRectangle(shape);
        break;
      case 'Fan':
        this.drawFan(shape);
        break;
      case 'Bow':
        this.drawBow(shape);
        break;
      case 'Polygon':
        this.drawPolygon(shape);
        break;
      case 'Polyline':
        this.drawPolyline(shape);
        break;
      case 'PointText':
        this.drawPointText(shape);
        break;
      case 'Image':
        this.drawImage(shape);
        break;
      case 'Bounds':
        this.drawBounds(shape);
        break;
      default:
        console.log('drawShapes(): unknown shape: ', shape);
    }
    if (shape.children != null) {
      this.drawShapes(shape.children);
    }
    if (this.isShowKeyPoints) {
      this.drawShapes(shape.keyPoints);
    }
    return this;
  };

  Renderer.prototype.drawPoint = function(shape) {
    this.context.globalAlpha = shape.opacity;
    if (shape.fillStyle != null) {
      this.context.fillStyle = shape.fillStyle;
      this.context.fillRect(shape.x - Bu.POINT_RENDER_SIZE / 2, shape.y - Bu.POINT_RENDER_SIZE / 2, Bu.POINT_RENDER_SIZE, Bu.POINT_RENDER_SIZE);
    }
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.strokeRect(shape.x - Bu.POINT_RENDER_SIZE / 2, shape.y - Bu.POINT_RENDER_SIZE / 2, Bu.POINT_RENDER_SIZE, Bu.POINT_RENDER_SIZE);
    }
    return this;
  };

  Renderer.prototype.drawLine = function(shape) {
    this.context.globalAlpha = shape.opacity;
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      this.context.beginPath();
      if (shape.dashStyle) {
        this.context.dashedLine(shape.points[0].x, shape.points[0].y, shape.points[1].x, shape.points[1].y, shape.dashStyle, shape.dashDelta);
      } else {
        this.context.lineTo(shape.points[0].x, shape.points[0].y);
        this.context.lineTo(shape.points[1].x, shape.points[1].y);
        this.context.closePath();
      }
      this.context.stroke();
    }
    return this;
  };

  Renderer.prototype.drawCircle = function(shape) {
    this.context.globalAlpha = shape.opacity;
    this.context.beginPath();
    this.context.arc(shape.cx, shape.cy, shape.radius, 0, Math.PI * 2);
    this.context.closePath();
    if (shape.fillStyle != null) {
      this.context.fillStyle = shape.fillStyle;
      this.context.fill();
    }
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      this.context.stroke();
    }
    return this;
  };

  Renderer.prototype.drawTriangle = function(shape) {
    var pts;
    this.context.globalAlpha = shape.opacity;
    this.context.beginPath();
    this.context.lineTo(shape.points[0].x, shape.points[0].y);
    this.context.lineTo(shape.points[1].x, shape.points[1].y);
    this.context.lineTo(shape.points[2].x, shape.points[2].y);
    this.context.closePath();
    if (shape.fillStyle != null) {
      this.context.fillStyle = shape.fillStyle;
      this.context.fill();
    }
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      if (shape.dashStyle) {
        this.context.beginPath();
        pts = shape.points;
        this.context.dashedLine(pts[0].x, pts[0].y, pts[1].x, pts[1].y, shape.dashStyle, shape.dashDelta);
        this.context.dashedLine(pts[1].x, pts[1].y, pts[2].x, pts[2].y, shape.dashStyle, shape.dashDelta);
        this.context.dashedLine(pts[2].x, pts[2].y, pts[0].x, pts[0].y, shape.dashStyle, shape.dashDelta);
      }
      this.context.stroke();
    }
    return this;
  };

  Renderer.prototype.drawRectangle = function(shape) {
    var xL, xR, yB, yT;
    this.context.globalAlpha = shape.opacity;
    if (shape.fillStyle != null) {
      this.context.fillStyle = shape.fillStyle;
      this.context.fillRect(shape.position.x, shape.position.y, shape.size.width, shape.size.height);
    }
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      if (!shape.dashStyle) {
        this.context.strokeRect(shape.position.x, shape.position.y, shape.size.width, shape.size.height);
      } else {
        this.context.beginPath();
        xL = shape.position.x;
        xR = shape.pointRB.x;
        yT = shape.position.y;
        yB = shape.pointRB.y;
        this.context.dashedLine(xL, yT, xR, yT, shape.dashStyle, shape.dashDelta);
        this.context.dashedLine(xR, yT, xR, yB, shape.dashStyle, shape.dashDelta);
        this.context.dashedLine(xR, yB, xL, yB, shape.dashStyle, shape.dashDelta);
        this.context.dashedLine(xL, yB, xL, yT, shape.dashStyle, shape.dashDelta);
        this.context.stroke();
      }
    }
    return this;
  };

  Renderer.prototype.drawFan = function(shape) {
    this.context.globalAlpha = shape.opacity;
    this.context.beginPath();
    this.context.arc(shape.cx, shape.cy, shape.radius, shape.aFrom, shape.aTo);
    this.context.lineTo(shape.cx, shape.cy);
    this.context.closePath();
    if (shape.fillStyle != null) {
      this.context.fillStyle = shape.fillStyle;
      this.context.fill();
    }
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      this.context.stroke();
    }
    return this;
  };

  Renderer.prototype.drawBow = function(shape) {
    this.context.globalAlpha = shape.opacity;
    this.context.beginPath();
    this.context.arc(shape.cx, shape.cy, shape.radius, shape.aFrom, shape.aTo);
    this.context.closePath();
    if (shape.fillStyle != null) {
      this.context.fillStyle = shape.fillStyle;
      this.context.fill();
    }
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      this.context.stroke();
    }
    return this;
  };

  Renderer.prototype.drawPolygon = function(shape) {
    var i, l, len, len1, o, point, pts, ref, ref1;
    this.context.globalAlpha = shape.opacity;
    this.context.beginPath();
    ref = shape.vertices;
    for (l = 0, len1 = ref.length; l < len1; l++) {
      point = ref[l];
      this.context.lineTo(point.x, point.y);
    }
    this.context.closePath();
    if (shape.fillStyle != null) {
      this.context.fillStyle = shape.fillStyle;
      this.context.fill();
    }
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      len = shape.vertices.length;
      if (shape.dashStyle && len > 0) {
        this.context.beginPath();
        pts = shape.vertices;
        for (i = o = 0, ref1 = len - 1; 0 <= ref1 ? o < ref1 : o > ref1; i = 0 <= ref1 ? ++o : --o) {
          this.context.dashedLine(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, shape.dashStyle, shape.dashDelta);
        }
        this.context.dashedLine(pts[len - 1].x, pts[len - 1].y, pts[0].x, pts[0].y, shape.dashStyle, shape.dashDelta);
        this.context.stroke();
      }
      this.context.stroke();
    }
    return this;
  };

  Renderer.prototype.drawPolyline = function(shape) {
    var i, l, len1, o, point, pts, ref, ref1;
    if (shape.strokeStyle != null) {
      this.context.globalAlpha = shape.opacity;
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      this.context.beginPath();
      if (!shape.dashStyle) {
        ref = shape.vertices;
        for (l = 0, len1 = ref.length; l < len1; l++) {
          point = ref[l];
          this.context.lineTo(point.x, point.y);
        }
      } else {
        pts = shape.vertices;
        for (i = o = 0, ref1 = pts.length - 1; 0 <= ref1 ? o < ref1 : o > ref1; i = 0 <= ref1 ? ++o : --o) {
          this.context.dashedLine(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, shape.dashStyle, shape.dashDelta);
        }
      }
      this.context.stroke();
    }
    return this;
  };

  Renderer.prototype.drawPointText = function(shape) {
    this.context.globalAlpha = shape.opacity;
    this.context.textAlign = shape.textAlign;
    this.context.textBaseline = shape.textBaseline;
    this.context.font = shape.font;
    if (shape.strokeStyle != null) {
      this.context.strokeStyle = shape.strokeStyle;
      this.context.lineWidth = shape.lineWidth;
      this.context.strokeText(shape.text, shape.x, shape.y);
    }
    if (shape.fillStyle != null) {
      this.context.fillStyle = shape.fillStyle;
      this.context.fillText(shape.text, shape.x, shape.y);
    }
    return this;
  };

  Renderer.prototype.drawImage = function(shape) {
    var dx, dy, h, w;
    if (shape.loaded) {
      this.context.save();
      this.context.globalAlpha = shape.opacity;
      w = shape.size.width * shape.scale.x;
      h = shape.size.height * shape.scale.y;
      dx = -w * shape.pivot.x;
      dy = -h * shape.pivot.y;
      this.context.translate(shape.position.x, shape.position.y);
      this.context.rotate(shape.rotation);
      this.context.drawImage(shape.image, dx, dy, w, h);
      this.context.restore();
    }
    return this;
  };

  Renderer.prototype.drawBounds = function(bounds) {
    this.context.strokeStyle = bounds.strokeStyle;
    this.context.beginPath();
    this.context.dashedLine(bounds.x1, bounds.y1, bounds.x2, bounds.y1, bounds.dashStyle, bounds.dashDelta);
    this.context.dashedLine(bounds.x2, bounds.y1, bounds.x2, bounds.y2, bounds.dashStyle, bounds.dashDelta);
    this.context.dashedLine(bounds.x2, bounds.y2, bounds.x1, bounds.y2, bounds.dashStyle, bounds.dashDelta);
    this.context.dashedLine(bounds.x1, bounds.y2, bounds.x1, bounds.y1, bounds.dashStyle, bounds.dashDelta);
    this.context.stroke();
    return this;
  };

  return Renderer;

})();

((function(_this) {
  return function() {
    var CP;
    CP = window.CanvasRenderingContext2D && CanvasRenderingContext2D.prototype;
    return CP.dashedLine = function(x, y, x2, y2, da, delta) {
      var dc, di, draw, dx, dy, i, l, len, len1, lenU, rot;
      if (da == null) {
        da = Bu.DEFAULT_DASH_STYLE;
      }
      if (delta == null) {
        delta = 0;
      }
      this.save();
      dx = x2 - x;
      dy = y2 - y;
      len = Bu.bevel(dx, dy);
      rot = Math.atan2(dy, dx);
      this.translate(x, y);
      this.rotate(rot);
      dc = da.length;
      di = 0;
      draw = true;
      lenU = 0;
      for (l = 0, len1 = da.length; l < len1; l++) {
        i = da[l];
        lenU += i;
      }
      delta %= lenU;
      x = delta;
      this.moveTo(0, 0);
      while (len > x) {
        di += 1;
        x += da[di % dc];
        if (x > len) {
          x = len;
        }
        if (draw) {
          this.lineTo(x, 0);
        } else {
          this.moveTo(x, 0);
        }
        draw = !draw;
      }
      this.restore();
      return this;
    };
  };
})(this))();

Bu.RandomShapeGenerator = (function() {
  var MARGIN;

  MARGIN = 30;

  function RandomShapeGenerator(renderer) {
    this.renderer = renderer;
  }

  RandomShapeGenerator.prototype.randomX = function() {
    return Bu.rand(MARGIN, this.renderer.width - MARGIN * 2);
  };

  RandomShapeGenerator.prototype.randomY = function() {
    return Bu.rand(MARGIN, this.renderer.height - MARGIN * 2);
  };

  RandomShapeGenerator.prototype.randomRadius = function() {
    return Bu.rand(5, Math.min(this.renderer.width, this.renderer.height) / 2);
  };

  RandomShapeGenerator.prototype.generateCircle = function() {
    var circle;
    circle = new Bu.Circle(this.randomX(), this.randomY(), this.randomRadius());
    circle.center.label = 'O';
    return circle;
  };

  RandomShapeGenerator.prototype.generateBow = function() {
    var aFrom, aTo, bow;
    aFrom = Bu.rand(Math.PI * 2);
    aTo = aFrom + Bu.rand(Math.PI / 2, Math.PI * 2);
    bow = new Bu.Bow(this.randomX(), this.randomY(), this.randomRadius(), aFrom, aTo);
    bow.string.points[0].label = 'A';
    bow.string.points[1].label = 'B';
    return bow;
  };

  RandomShapeGenerator.prototype.generateTriangle = function() {
    var i, l, points, triangle;
    points = [];
    for (i = l = 0; l <= 2; i = ++l) {
      points[i] = new Bu.Point(this.randomX(), this.randomY());
    }
    triangle = new Bu.Triangle(points[0], points[1], points[2]);
    triangle.points[0].label = 'A';
    triangle.points[1].label = 'B';
    triangle.points[2].label = 'C';
    return triangle;
  };

  RandomShapeGenerator.prototype.generateRectangle = function() {
    return new Bu.Rectangle(Bu.rand(this.renderer.width), Bu.rand(this.renderer.height), Bu.rand(this.renderer.width / 2), Bu.rand(this.renderer.height / 2));
  };

  RandomShapeGenerator.prototype.generateFan = function() {
    var aFrom, aTo, fan;
    aFrom = Bu.rand(Math.PI * 2);
    aTo = aFrom + Bu.rand(Math.PI / 2, Math.PI * 2);
    fan = new Bu.Fan(this.randomX(), this.randomY(), this.randomRadius(), aFrom, aTo);
    fan.string.points[0].label = 'A';
    fan.string.points[1].label = 'B';
    return fan;
  };

  RandomShapeGenerator.prototype.generatePolygon = function() {
    var i, l, point, points;
    points = [];
    for (i = l = 0; l <= 3; i = ++l) {
      point = new Bu.Point(this.randomX(), this.randomY());
      point.label = 'P' + i;
      points.push(point);
    }
    return new Bu.Polygon(points);
  };

  RandomShapeGenerator.prototype.generateLine = function() {
    var line;
    line = new Bu.Line(this.randomX(), this.randomY(), this.randomX(), this.randomY());
    line.points[0].label = 'A';
    line.points[1].label = 'B';
    return line;
  };

  RandomShapeGenerator.prototype.generatePolyline = function() {
    var i, l, point, polyline;
    polyline = new Bu.Polyline;
    for (i = l = 0; l <= 3; i = ++l) {
      point = new Bu.Point(this.randomX(), this.randomY());
      point.label = 'P' + i;
      polyline.addPoint(point);
    }
    return polyline;
  };

  return RandomShapeGenerator;

})();

//# sourceMappingURL=bu.js.map
